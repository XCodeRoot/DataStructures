package lanqiao_issue._2019_Java_B;

import java.util.LinkedList;
import java.util.Queue;
import java.util.Scanner;

public class _05迷宫 {

    static int[] x= {1, 0, 0, -1};
    static int[] y= {0, -1, 1, 0};
    static int[][] vis=new int[30][50];//标记走过的路为墙,如果为1则不能走
    static char[][] map=new char[30][50];//map是题目给的迷宫图
    static char[] direction={'D','L','R','U'};
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        for (int i = 0; i < 30; i++) {
            map[i]=sc.next().toCharArray();//字符串转数组
        }
    /**     走迷宫的最短路径问题
     *  注意题目:使用步数最少，那就得用BFS，并且要保证字典序最小，那就是按照给定的字典序来移动，记录下每次移动的方位即可
     *  先建一个 node类, map[][],vis[][],存储迷宫信息
     *  再用 链表 模拟 队列 ,将起点加到队列里
     *
     *  队列里
     */
        node b=new node(0,0,"");//起点要入队列
        Queue<node> Q =new LinkedList<>();
        Q.offer(b);//起点入队列

        vis[0][0]=1;//标记 起点为墙,不能走

        // BFS 不需要回溯 , 第一次到达的,就是步数最少的,就是最短路径
        while(!Q.isEmpty()){//队列非空时,继续走
            node tmp=Q.poll();// .poll()返回队列首节点

            //到达终点
            if(tmp.x==29&&tmp.y==49){
                System.out.println(tmp.move);
            }

            for(int i=0;i<4;i++){
                node temp=new node();//每次循环都 新建一个node,用来存放下一步走的方向(有, 下 左 右 上,四个方向)
                temp.x=tmp.x+x[i];//每次循环对应 Down Left Right Up
                temp.y=tmp.y+y[i];
                // temp.x<0||temp.y<0||temp.x>29||temp.y>49 保证 move以后的 下标(x,y) 不越界 ,
                // vis[temp.x][temp.y]==1 保证不为走过的路 ,
                // map[temp.x][temp.y]=='1' 保证不为墙
                if(temp.x<0||temp.y<0||temp.x>29||temp.y>49||vis[temp.x][temp.y]==1||map[temp.x][temp.y]=='1'){
                    continue;
                }
                vis[temp.x][temp.y]=1;//把走过的路标记为 墙
                String moveTemp=tmp.move+direction[i];//把 当前选择走的方向 和 以前走的路径 的字符串加起来
                temp.move=moveTemp;
                //入队
                Q.offer(temp);


            }
        }


    }

}
class node{//节点
    int x,y;
    String move;
    public node(){}
    public node(int x,int y,String move){
        this.x=x;
        this.y=y;
        this.move=move;
    }
}
    /*
01010101001011001001010110010110100100001000101010
00001000100000101010010000100000001001100110100101
01111011010010001000001101001011100011000000010000
01000000001010100011010000101000001010101011001011
00011111000000101000010010100010100000101100000000
11001000110101000010101100011010011010101011110111
00011011010101001001001010000001000101001110000000
10100000101000100110101010111110011000010000111010
00111000001010100001100010000001000101001100001001
11000110100001110010001001010101010101010001101000
00010000100100000101001010101110100010101010000101
11100100101001001000010000010101010100100100010100
00000010000000101011001111010001100000101010100011
10101010011100001000011000010110011110110100001000
10101010100001101010100101000010100000111011101001
10000000101100010000101100101101001011100000000100
10101001000000010100100001000100000100011110101001
00101001010101101001010100011010101101110000110101
11001010000100001100000010100101000001000111000010
00001000110000110101101000000100101001001000011101
10100101000101000000001110110010110101101010100001
00101000010000110101010000100010001001000100010101
10100001000110010001000010101001010101011111010010
00000100101000000110010100101001000001000000000010
11010000001001110111001001000011101001011011101000
00000110100010001000100000001000011101000000110011
10101000101000100010001111100010101001010000001000
10000010100101001010110000000100101010001011101000
00111100001000010000000110111000000001000000001011
10000001100111010111010001000110111010101101111000

     */
